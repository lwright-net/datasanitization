#+title: Script for sanitizing disks
#+author: Lane Wright
#+PROPERTY: header-args :tangle sanitize.sh
#+auto_tangle: t

* About this script
I came across a need at work to sanitize disks from decommissioned laptops with potentially sensitive data on them.
This ispired me to write my first 'proper' script, that does a real task that would be needed in a business environment.
Goals for this script are:
 + follow NIST guidelines laid out in document 800-88 to ensure no data can be recovered
 + provide some sort of logging functionality that is printable on paper records
 + do this as fast as possible (some of these disks can be large)
 + be simple enough operators unfamiliar with Linux can use this script
In this script I will depend on the following to be installed:
 + the GNU =coreutils=
   + =dd= (byte-level utility for copying data)
   + =tr= (translate)
 + the built-in =linux= utils
   + =lsblk= (list block devices)
 + the =bash= shell
* Find out which disk to sanitize
First task is to find out which disk needs to be sanitized.
Ideally this will be as many as you like with the limiting factor being hardware this script is ran on.
To make it a little easier for the operator to figure out which disk is which I will call =lsblk=.
#+BEGIN_SRC bash :shebang "#!/bin/bash"
printf "===============\n"
printf "This script is potentially dangerous! \nIt WILL destroy data and make said data unrecoverable! \n"
printf "===============\n"
finddisktokill() {
printf "Please choose disk to sanitize.\nBe mindful of which disk the OS is written to! \n"
lsblk
read -p "Enter the disk name *EXACTLY* as shown in the chart above: " disktokill
}
finddisktokill()
#+END_SRC
* First pass write zeros
Now that we know what disk to kill we will need to do a pass of writing zeros in every location.
#+BEGIN_SRC bash
while true; do
read -p "You selected $disktokill. Is this correct? (y/n)" yn
    if [ -b "/dev/$disktokill" ]; then
     case $yn in
         [Yy]* ) read -p "Are you sure $disktokill is correct? (y/n)" yn2
                 case $yn2 in
                     [Yy]* ) sudo dd if=/dev/zero of=/dev/$disktokill bs=64K status=progress ;
                             break;;
                     ,* ) printf "Aborting sanitization!\n";
                          break;;
                 esac
                 break;;
         ,* ) printf "Aborting sanitization!\n";
              break;;
     esac
    else
     printf "$disktokill does not exist in /dev/ \n"
     finddisktokill
    fi
break;;
done
#+END_SRC
* Second pass write ones
We can use the =tr= (translate) command to turn a zero from =/dev/zero= to a one.
With our zeros turned to ones we can then write them to the disk in mostly the same way.
* Third pass write random data
